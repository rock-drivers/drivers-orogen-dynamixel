name "dynamixel"

using_task_library "interfaces"
using_library "dynamixel"
import_types_from "DynamixelDaisyChain.hpp"

task_context "Task" do
    subclasses "interfaces::Servo"
    needs_configuration

    property("device", "/std/string").
        doc "the device file used to connect to the RS485 bus"

    property("servo_id", "int").
        doc "the dynamixel id off the tilt angle"

    property("dynamixels", "/std/vector</dynamixel/DynamixelDaisyChain>").
        doc "Use this vector if there are several dynamixels daisy chained. In this case 'servo_id' is ignored and the operation setDynamixelActive() has to be used. By default the last dynamixel is the active one."

    property("cw_slope", "int", 32).
        doc "the dynamixel slope A (see RX-28 manual)"

    property("cw_margin", "int", 1).
        doc "the dynamixel margin B (see RX-28 manual)"

    property("ccw_margin", "int",1).
        doc "the dynamixel margin C (see RX-28 manual)"

    property("ccw_slope", "int",32).
        doc "the dynamixel slope D (see RX-28 manual)"

    property("punch", "int",32).
        doc "the dynamixel punch E (see RX-28 manual)"

    property("torque_limit", "int", 512).
        doc "the dynamixel punch E (see RX-28 manual)"

    property("torque_enable", "bool", false).
        doc "the dynamixel punch E (see RX-28 manual)"

    property("upperFrameName", "std/string", "upper_dynamixel").
	doc "The name of the frame, where the upper part (rotating) of the servo is mounted"

    property("lowerFrameName", "std/string", "lower_dynamixel").
	doc "The name of the frame, where the lower part (fixed) of the servo is mounted"

    property("num_resend", "int", 0).
        doc "If > 0 each command will be resend if an error occurre. Can be used to handle communication errors which occur seldomly."

    output_port('lowerDynamixel2UpperDynamixel', '/base/samples/RigidBodyState').
	doc "transformation between the lower and upper frame. It is allways assumed, that the axis of the servo is located on the X-Axis"

    operation("setDynamixelActive").
        returns('bool').
        argument("servo_id", "int", "Activates the servo which belongs to the passed servo id")

    default_activity :periodic, 0.01
    default_activity 'fd_driven' 

    exception_states :IO_ERROR
end

using_task_library "logger"
deployment "test" do
    do_not_install
    t = task("dynamixel_Task", "dynamixel::Task").
        periodic(0.01)

    add_default_logger

    if !corba_enabled?
        browse t
    end
end

